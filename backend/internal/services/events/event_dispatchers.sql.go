// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: event_dispatchers.sql

package events

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countEventDispatchers = `-- name: CountEventDispatchers :one
SELECT COUNT(*) FROM event_dispatchers
WHERE environment_id = $1
    AND ($2::TEXT IS NULL OR event = $2)
    AND ($3::TEXT IS NULL OR source = $3)
    AND ($4::BOOLEAN = false OR enabled = true)
`

type CountEventDispatchersParams struct {
	EnvironmentID pgtype.UUID `json:"environment_id"`
	Column2       string      `json:"column_2"`
	Column3       string      `json:"column_3"`
	Column4       bool        `json:"column_4"`
}

func (q *Queries) CountEventDispatchers(ctx context.Context, arg CountEventDispatchersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countEventDispatchers,
		arg.EnvironmentID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEventDispatcher = `-- name: CreateEventDispatcher :one

INSERT INTO event_dispatchers (
    event,
    source,
    payload_filter,
    context_filter,
    manual,
    dispatchable_id,
    dispatchable,
    enabled,
    environment_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, event, source, payload_filter, context_filter, manual, dispatchable_id, dispatchable, enabled, environment_id, created_at, updated_at
`

type CreateEventDispatcherParams struct {
	Event          string      `json:"event"`
	Source         string      `json:"source"`
	PayloadFilter  []byte      `json:"payload_filter"`
	ContextFilter  []byte      `json:"context_filter"`
	Manual         bool        `json:"manual"`
	DispatchableID string      `json:"dispatchable_id"`
	Dispatchable   []byte      `json:"dispatchable"`
	Enabled        bool        `json:"enabled"`
	EnvironmentID  pgtype.UUID `json:"environment_id"`
}

// event_dispatchers.sql
// Events Service - EventDispatcher 相关查询，对齐 trigger.dev 功能
func (q *Queries) CreateEventDispatcher(ctx context.Context, arg CreateEventDispatcherParams) (EventDispatchers, error) {
	row := q.db.QueryRow(ctx, createEventDispatcher,
		arg.Event,
		arg.Source,
		arg.PayloadFilter,
		arg.ContextFilter,
		arg.Manual,
		arg.DispatchableID,
		arg.Dispatchable,
		arg.Enabled,
		arg.EnvironmentID,
	)
	var i EventDispatchers
	err := row.Scan(
		&i.ID,
		&i.Event,
		&i.Source,
		&i.PayloadFilter,
		&i.ContextFilter,
		&i.Manual,
		&i.DispatchableID,
		&i.Dispatchable,
		&i.Enabled,
		&i.EnvironmentID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteEventDispatcher = `-- name: DeleteEventDispatcher :exec
DELETE FROM event_dispatchers WHERE id = $1
`

func (q *Queries) DeleteEventDispatcher(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteEventDispatcher, id)
	return err
}

const findEventDispatchers = `-- name: FindEventDispatchers :many
SELECT id, event, source, payload_filter, context_filter, manual, dispatchable_id, dispatchable, enabled, environment_id, created_at, updated_at FROM event_dispatchers
WHERE environment_id = $1
    AND event = $2
    AND source = $3
    AND ($4::BOOLEAN = false OR enabled = true)
    AND ($5::BOOLEAN IS NULL OR manual = $5)
ORDER BY created_at ASC
`

type FindEventDispatchersParams struct {
	EnvironmentID pgtype.UUID `json:"environment_id"`
	Event         string      `json:"event"`
	Source        string      `json:"source"`
	Column4       bool        `json:"column_4"`
	Column5       bool        `json:"column_5"`
}

// 查找匹配的事件调度器，对齐 trigger.dev DeliverEventService 逻辑
func (q *Queries) FindEventDispatchers(ctx context.Context, arg FindEventDispatchersParams) ([]EventDispatchers, error) {
	rows, err := q.db.Query(ctx, findEventDispatchers,
		arg.EnvironmentID,
		arg.Event,
		arg.Source,
		arg.Column4,
		arg.Column5,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventDispatchers
	for rows.Next() {
		var i EventDispatchers
		if err := rows.Scan(
			&i.ID,
			&i.Event,
			&i.Source,
			&i.PayloadFilter,
			&i.ContextFilter,
			&i.Manual,
			&i.DispatchableID,
			&i.Dispatchable,
			&i.Enabled,
			&i.EnvironmentID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventDispatcherByID = `-- name: GetEventDispatcherByID :one
SELECT id, event, source, payload_filter, context_filter, manual, dispatchable_id, dispatchable, enabled, environment_id, created_at, updated_at FROM event_dispatchers 
WHERE id = $1
`

func (q *Queries) GetEventDispatcherByID(ctx context.Context, id pgtype.UUID) (EventDispatchers, error) {
	row := q.db.QueryRow(ctx, getEventDispatcherByID, id)
	var i EventDispatchers
	err := row.Scan(
		&i.ID,
		&i.Event,
		&i.Source,
		&i.PayloadFilter,
		&i.ContextFilter,
		&i.Manual,
		&i.DispatchableID,
		&i.Dispatchable,
		&i.Enabled,
		&i.EnvironmentID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listEventDispatchers = `-- name: ListEventDispatchers :many
SELECT id, event, source, payload_filter, context_filter, manual, dispatchable_id, dispatchable, enabled, environment_id, created_at, updated_at FROM event_dispatchers
WHERE environment_id = $1
    AND ($2::TEXT IS NULL OR event = $2)
    AND ($3::TEXT IS NULL OR source = $3)
    AND ($4::BOOLEAN = false OR enabled = true)
ORDER BY created_at DESC
LIMIT $5 OFFSET $6
`

type ListEventDispatchersParams struct {
	EnvironmentID pgtype.UUID `json:"environment_id"`
	Column2       string      `json:"column_2"`
	Column3       string      `json:"column_3"`
	Column4       bool        `json:"column_4"`
	Limit         int32       `json:"limit"`
	Offset        int32       `json:"offset"`
}

func (q *Queries) ListEventDispatchers(ctx context.Context, arg ListEventDispatchersParams) ([]EventDispatchers, error) {
	rows, err := q.db.Query(ctx, listEventDispatchers,
		arg.EnvironmentID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventDispatchers
	for rows.Next() {
		var i EventDispatchers
		if err := rows.Scan(
			&i.ID,
			&i.Event,
			&i.Source,
			&i.PayloadFilter,
			&i.ContextFilter,
			&i.Manual,
			&i.DispatchableID,
			&i.Dispatchable,
			&i.Enabled,
			&i.EnvironmentID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEventDispatcherEnabled = `-- name: UpdateEventDispatcherEnabled :exec
UPDATE event_dispatchers 
SET enabled = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateEventDispatcherEnabledParams struct {
	ID      pgtype.UUID `json:"id"`
	Enabled bool        `json:"enabled"`
}

func (q *Queries) UpdateEventDispatcherEnabled(ctx context.Context, arg UpdateEventDispatcherEnabledParams) error {
	_, err := q.db.Exec(ctx, updateEventDispatcherEnabled, arg.ID, arg.Enabled)
	return err
}

const upsertEventDispatcher = `-- name: UpsertEventDispatcher :one
INSERT INTO event_dispatchers (
    event,
    source,
    payload_filter,
    context_filter,
    manual,
    dispatchable_id,
    dispatchable,
    enabled,
    environment_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
ON CONFLICT (dispatchable_id, environment_id)
DO UPDATE SET
    event = EXCLUDED.event,
    source = EXCLUDED.source,
    payload_filter = EXCLUDED.payload_filter,
    context_filter = EXCLUDED.context_filter,
    manual = EXCLUDED.manual,
    dispatchable = EXCLUDED.dispatchable,
    enabled = EXCLUDED.enabled,
    updated_at = NOW()
RETURNING id, event, source, payload_filter, context_filter, manual, dispatchable_id, dispatchable, enabled, environment_id, created_at, updated_at
`

type UpsertEventDispatcherParams struct {
	Event          string      `json:"event"`
	Source         string      `json:"source"`
	PayloadFilter  []byte      `json:"payload_filter"`
	ContextFilter  []byte      `json:"context_filter"`
	Manual         bool        `json:"manual"`
	DispatchableID string      `json:"dispatchable_id"`
	Dispatchable   []byte      `json:"dispatchable"`
	Enabled        bool        `json:"enabled"`
	EnvironmentID  pgtype.UUID `json:"environment_id"`
}

// Upsert 事件调度器，用于端点注册时更新调度器
func (q *Queries) UpsertEventDispatcher(ctx context.Context, arg UpsertEventDispatcherParams) (EventDispatchers, error) {
	row := q.db.QueryRow(ctx, upsertEventDispatcher,
		arg.Event,
		arg.Source,
		arg.PayloadFilter,
		arg.ContextFilter,
		arg.Manual,
		arg.DispatchableID,
		arg.Dispatchable,
		arg.Enabled,
		arg.EnvironmentID,
	)
	var i EventDispatchers
	err := row.Scan(
		&i.ID,
		&i.Event,
		&i.Source,
		&i.PayloadFilter,
		&i.ContextFilter,
		&i.Manual,
		&i.DispatchableID,
		&i.Dispatchable,
		&i.Enabled,
		&i.EnvironmentID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
