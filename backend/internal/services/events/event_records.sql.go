// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: event_records.sql

package events

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countEventRecords = `-- name: CountEventRecords :one
SELECT COUNT(*) FROM event_records
WHERE 
    ($1::UUID IS NULL OR environment_id = $1) AND
    ($2::UUID IS NULL OR project_id = $2) AND
    ($3::TEXT IS NULL OR source = $3) AND
    ($4::BOOLEAN IS NULL OR ($4 = true AND delivered_at IS NOT NULL) OR ($4 = false AND delivered_at IS NULL)) AND
    ($5::TIMESTAMPTZ IS NULL OR created_at >= $5) AND
    ($6::TIMESTAMPTZ IS NULL OR created_at <= $6)
`

type CountEventRecordsParams struct {
	Column1 pgtype.UUID        `json:"column_1"`
	Column2 pgtype.UUID        `json:"column_2"`
	Column3 string             `json:"column_3"`
	Column4 bool               `json:"column_4"`
	Column5 pgtype.Timestamptz `json:"column_5"`
	Column6 pgtype.Timestamptz `json:"column_6"`
}

func (q *Queries) CountEventRecords(ctx context.Context, arg CountEventRecordsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countEventRecords,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEventRecord = `-- name: CreateEventRecord :one

INSERT INTO event_records (
    event_id,
    name,
    timestamp,
    payload,
    context,
    source,
    organization_id,
    environment_id,
    project_id,
    external_account_id,
    deliver_at,
    is_test
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
) RETURNING id, event_id, name, source, payload, context, timestamp, environment_id, organization_id, project_id, is_test, created_at, updated_at, external_account_id, deliver_at, delivered_at
`

type CreateEventRecordParams struct {
	EventID           string             `json:"event_id"`
	Name              string             `json:"name"`
	Timestamp         pgtype.Timestamptz `json:"timestamp"`
	Payload           []byte             `json:"payload"`
	Context           []byte             `json:"context"`
	Source            string             `json:"source"`
	OrganizationID    pgtype.UUID        `json:"organization_id"`
	EnvironmentID     pgtype.UUID        `json:"environment_id"`
	ProjectID         pgtype.UUID        `json:"project_id"`
	ExternalAccountID pgtype.UUID        `json:"external_account_id"`
	DeliverAt         pgtype.Timestamptz `json:"deliver_at"`
	IsTest            bool               `json:"is_test"`
}

// event_records.sql
// Events Service - EventRecord 相关查询，对齐 trigger.dev 功能
func (q *Queries) CreateEventRecord(ctx context.Context, arg CreateEventRecordParams) (EventRecords, error) {
	row := q.db.QueryRow(ctx, createEventRecord,
		arg.EventID,
		arg.Name,
		arg.Timestamp,
		arg.Payload,
		arg.Context,
		arg.Source,
		arg.OrganizationID,
		arg.EnvironmentID,
		arg.ProjectID,
		arg.ExternalAccountID,
		arg.DeliverAt,
		arg.IsTest,
	)
	var i EventRecords
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.Name,
		&i.Source,
		&i.Payload,
		&i.Context,
		&i.Timestamp,
		&i.EnvironmentID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.IsTest,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExternalAccountID,
		&i.DeliverAt,
		&i.DeliveredAt,
	)
	return i, err
}

const deleteEventRecord = `-- name: DeleteEventRecord :exec
DELETE FROM event_records WHERE id = $1
`

func (q *Queries) DeleteEventRecord(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteEventRecord, id)
	return err
}

const getEventRecordByEventID = `-- name: GetEventRecordByEventID :one
SELECT id, event_id, name, source, payload, context, timestamp, environment_id, organization_id, project_id, is_test, created_at, updated_at, external_account_id, deliver_at, delivered_at FROM event_records 
WHERE event_id = $1 AND environment_id = $2
`

type GetEventRecordByEventIDParams struct {
	EventID       string      `json:"event_id"`
	EnvironmentID pgtype.UUID `json:"environment_id"`
}

func (q *Queries) GetEventRecordByEventID(ctx context.Context, arg GetEventRecordByEventIDParams) (EventRecords, error) {
	row := q.db.QueryRow(ctx, getEventRecordByEventID, arg.EventID, arg.EnvironmentID)
	var i EventRecords
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.Name,
		&i.Source,
		&i.Payload,
		&i.Context,
		&i.Timestamp,
		&i.EnvironmentID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.IsTest,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExternalAccountID,
		&i.DeliverAt,
		&i.DeliveredAt,
	)
	return i, err
}

const getEventRecordByID = `-- name: GetEventRecordByID :one
SELECT id, event_id, name, source, payload, context, timestamp, environment_id, organization_id, project_id, is_test, created_at, updated_at, external_account_id, deliver_at, delivered_at FROM event_records 
WHERE id = $1
`

func (q *Queries) GetEventRecordByID(ctx context.Context, id pgtype.UUID) (EventRecords, error) {
	row := q.db.QueryRow(ctx, getEventRecordByID, id)
	var i EventRecords
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.Name,
		&i.Source,
		&i.Payload,
		&i.Context,
		&i.Timestamp,
		&i.EnvironmentID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.IsTest,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExternalAccountID,
		&i.DeliverAt,
		&i.DeliveredAt,
	)
	return i, err
}

const listEventRecords = `-- name: ListEventRecords :many
SELECT id, event_id, name, source, payload, context, timestamp, environment_id, organization_id, project_id, is_test, created_at, updated_at, external_account_id, deliver_at, delivered_at FROM event_records
WHERE 
    ($1::UUID IS NULL OR environment_id = $1) AND
    ($2::UUID IS NULL OR project_id = $2) AND
    ($3::TEXT IS NULL OR source = $3) AND
    ($4::BOOLEAN IS NULL OR ($4 = true AND delivered_at IS NOT NULL) OR ($4 = false AND delivered_at IS NULL)) AND
    ($5::TIMESTAMPTZ IS NULL OR created_at >= $5) AND
    ($6::TIMESTAMPTZ IS NULL OR created_at <= $6)
ORDER BY created_at DESC
LIMIT $7 OFFSET $8
`

type ListEventRecordsParams struct {
	Column1 pgtype.UUID        `json:"column_1"`
	Column2 pgtype.UUID        `json:"column_2"`
	Column3 string             `json:"column_3"`
	Column4 bool               `json:"column_4"`
	Column5 pgtype.Timestamptz `json:"column_5"`
	Column6 pgtype.Timestamptz `json:"column_6"`
	Limit   int32              `json:"limit"`
	Offset  int32              `json:"offset"`
}

func (q *Queries) ListEventRecords(ctx context.Context, arg ListEventRecordsParams) ([]EventRecords, error) {
	rows, err := q.db.Query(ctx, listEventRecords,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventRecords
	for rows.Next() {
		var i EventRecords
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.Name,
			&i.Source,
			&i.Payload,
			&i.Context,
			&i.Timestamp,
			&i.EnvironmentID,
			&i.OrganizationID,
			&i.ProjectID,
			&i.IsTest,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExternalAccountID,
			&i.DeliverAt,
			&i.DeliveredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingEventRecords = `-- name: ListPendingEventRecords :many
SELECT id, event_id, name, source, payload, context, timestamp, environment_id, organization_id, project_id, is_test, created_at, updated_at, external_account_id, deliver_at, delivered_at FROM event_records
WHERE delivered_at IS NULL 
    AND deliver_at <= NOW()
    AND ($1::UUID IS NULL OR environment_id = $1)
ORDER BY deliver_at ASC
LIMIT $2
`

type ListPendingEventRecordsParams struct {
	Column1 pgtype.UUID `json:"column_1"`
	Limit   int32       `json:"limit"`
}

// 获取待投递的事件记录，用于调度
func (q *Queries) ListPendingEventRecords(ctx context.Context, arg ListPendingEventRecordsParams) ([]EventRecords, error) {
	rows, err := q.db.Query(ctx, listPendingEventRecords, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventRecords
	for rows.Next() {
		var i EventRecords
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.Name,
			&i.Source,
			&i.Payload,
			&i.Context,
			&i.Timestamp,
			&i.EnvironmentID,
			&i.OrganizationID,
			&i.ProjectID,
			&i.IsTest,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExternalAccountID,
			&i.DeliverAt,
			&i.DeliveredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEventRecordDeliveredAt = `-- name: UpdateEventRecordDeliveredAt :exec
UPDATE event_records 
SET delivered_at = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateEventRecordDeliveredAtParams struct {
	ID          pgtype.UUID        `json:"id"`
	DeliveredAt pgtype.Timestamptz `json:"delivered_at"`
}

func (q *Queries) UpdateEventRecordDeliveredAt(ctx context.Context, arg UpdateEventRecordDeliveredAtParams) error {
	_, err := q.db.Exec(ctx, updateEventRecordDeliveredAt, arg.ID, arg.DeliveredAt)
	return err
}
