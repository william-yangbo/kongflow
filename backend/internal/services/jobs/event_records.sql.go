// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: event_records.sql

package jobs

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countEventRecordsByEnvironment = `-- name: CountEventRecordsByEnvironment :one
SELECT COUNT(*) FROM event_records WHERE environment_id = $1
`

func (q *Queries) CountEventRecordsByEnvironment(ctx context.Context, environmentID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countEventRecordsByEnvironment, environmentID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTestEventRecords = `-- name: CountTestEventRecords :one
SELECT COUNT(*) FROM event_records WHERE environment_id = $1 AND is_test = true
`

func (q *Queries) CountTestEventRecords(ctx context.Context, environmentID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countTestEventRecords, environmentID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEventRecord = `-- name: CreateEventRecord :one

INSERT INTO event_records (
    event_id, name, source, payload, context, timestamp,
    environment_id, organization_id, project_id, is_test
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, event_id, name, source, payload, context, timestamp,
    environment_id, organization_id, project_id, is_test, created_at, updated_at
`

type CreateEventRecordParams struct {
	EventID        string             `json:"event_id"`
	Name           string             `json:"name"`
	Source         string             `json:"source"`
	Payload        []byte             `json:"payload"`
	Context        []byte             `json:"context"`
	Timestamp      pgtype.Timestamptz `json:"timestamp"`
	EnvironmentID  pgtype.UUID        `json:"environment_id"`
	OrganizationID pgtype.UUID        `json:"organization_id"`
	ProjectID      pgtype.UUID        `json:"project_id"`
	IsTest         bool               `json:"is_test"`
}

// event_records.sql
// EventRecord 事件记录相关查询
func (q *Queries) CreateEventRecord(ctx context.Context, arg CreateEventRecordParams) (EventRecords, error) {
	row := q.db.QueryRow(ctx, createEventRecord,
		arg.EventID,
		arg.Name,
		arg.Source,
		arg.Payload,
		arg.Context,
		arg.Timestamp,
		arg.EnvironmentID,
		arg.OrganizationID,
		arg.ProjectID,
		arg.IsTest,
	)
	var i EventRecords
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.Name,
		&i.Source,
		&i.Payload,
		&i.Context,
		&i.Timestamp,
		&i.EnvironmentID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.IsTest,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteEventRecord = `-- name: DeleteEventRecord :exec
DELETE FROM event_records WHERE id = $1
`

func (q *Queries) DeleteEventRecord(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteEventRecord, id)
	return err
}

const deleteEventRecordByEventID = `-- name: DeleteEventRecordByEventID :exec
DELETE FROM event_records WHERE event_id = $1 AND environment_id = $2
`

type DeleteEventRecordByEventIDParams struct {
	EventID       string      `json:"event_id"`
	EnvironmentID pgtype.UUID `json:"environment_id"`
}

func (q *Queries) DeleteEventRecordByEventID(ctx context.Context, arg DeleteEventRecordByEventIDParams) error {
	_, err := q.db.Exec(ctx, deleteEventRecordByEventID, arg.EventID, arg.EnvironmentID)
	return err
}

const getEventRecordByEventID = `-- name: GetEventRecordByEventID :one
SELECT id, event_id, name, source, payload, context, timestamp,
    environment_id, organization_id, project_id, is_test, created_at, updated_at
FROM event_records 
WHERE event_id = $1 AND environment_id = $2
`

type GetEventRecordByEventIDParams struct {
	EventID       string      `json:"event_id"`
	EnvironmentID pgtype.UUID `json:"environment_id"`
}

func (q *Queries) GetEventRecordByEventID(ctx context.Context, arg GetEventRecordByEventIDParams) (EventRecords, error) {
	row := q.db.QueryRow(ctx, getEventRecordByEventID, arg.EventID, arg.EnvironmentID)
	var i EventRecords
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.Name,
		&i.Source,
		&i.Payload,
		&i.Context,
		&i.Timestamp,
		&i.EnvironmentID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.IsTest,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEventRecordByID = `-- name: GetEventRecordByID :one
SELECT id, event_id, name, source, payload, context, timestamp,
    environment_id, organization_id, project_id, is_test, created_at, updated_at
FROM event_records 
WHERE id = $1
`

func (q *Queries) GetEventRecordByID(ctx context.Context, id pgtype.UUID) (EventRecords, error) {
	row := q.db.QueryRow(ctx, getEventRecordByID, id)
	var i EventRecords
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.Name,
		&i.Source,
		&i.Payload,
		&i.Context,
		&i.Timestamp,
		&i.EnvironmentID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.IsTest,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listEventRecordsByEnvironment = `-- name: ListEventRecordsByEnvironment :many
SELECT id, event_id, name, source, payload, context, timestamp,
    environment_id, organization_id, project_id, is_test, created_at, updated_at
FROM event_records 
WHERE environment_id = $1
ORDER BY timestamp DESC
LIMIT $2 OFFSET $3
`

type ListEventRecordsByEnvironmentParams struct {
	EnvironmentID pgtype.UUID `json:"environment_id"`
	Limit         int32       `json:"limit"`
	Offset        int32       `json:"offset"`
}

func (q *Queries) ListEventRecordsByEnvironment(ctx context.Context, arg ListEventRecordsByEnvironmentParams) ([]EventRecords, error) {
	rows, err := q.db.Query(ctx, listEventRecordsByEnvironment, arg.EnvironmentID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventRecords
	for rows.Next() {
		var i EventRecords
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.Name,
			&i.Source,
			&i.Payload,
			&i.Context,
			&i.Timestamp,
			&i.EnvironmentID,
			&i.OrganizationID,
			&i.ProjectID,
			&i.IsTest,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventRecordsByNameAndSource = `-- name: ListEventRecordsByNameAndSource :many
SELECT id, event_id, name, source, payload, context, timestamp,
    environment_id, organization_id, project_id, is_test, created_at, updated_at
FROM event_records 
WHERE environment_id = $1 AND name = $2 AND source = $3
ORDER BY timestamp DESC
LIMIT $4 OFFSET $5
`

type ListEventRecordsByNameAndSourceParams struct {
	EnvironmentID pgtype.UUID `json:"environment_id"`
	Name          string      `json:"name"`
	Source        string      `json:"source"`
	Limit         int32       `json:"limit"`
	Offset        int32       `json:"offset"`
}

func (q *Queries) ListEventRecordsByNameAndSource(ctx context.Context, arg ListEventRecordsByNameAndSourceParams) ([]EventRecords, error) {
	rows, err := q.db.Query(ctx, listEventRecordsByNameAndSource,
		arg.EnvironmentID,
		arg.Name,
		arg.Source,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventRecords
	for rows.Next() {
		var i EventRecords
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.Name,
			&i.Source,
			&i.Payload,
			&i.Context,
			&i.Timestamp,
			&i.EnvironmentID,
			&i.OrganizationID,
			&i.ProjectID,
			&i.IsTest,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTestEventRecords = `-- name: ListTestEventRecords :many
SELECT id, event_id, name, source, payload, context, timestamp,
    environment_id, organization_id, project_id, is_test, created_at, updated_at
FROM event_records 
WHERE environment_id = $1 AND is_test = true
ORDER BY timestamp DESC
LIMIT $2 OFFSET $3
`

type ListTestEventRecordsParams struct {
	EnvironmentID pgtype.UUID `json:"environment_id"`
	Limit         int32       `json:"limit"`
	Offset        int32       `json:"offset"`
}

func (q *Queries) ListTestEventRecords(ctx context.Context, arg ListTestEventRecordsParams) ([]EventRecords, error) {
	rows, err := q.db.Query(ctx, listTestEventRecords, arg.EnvironmentID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventRecords
	for rows.Next() {
		var i EventRecords
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.Name,
			&i.Source,
			&i.Payload,
			&i.Context,
			&i.Timestamp,
			&i.EnvironmentID,
			&i.OrganizationID,
			&i.ProjectID,
			&i.IsTest,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEventRecord = `-- name: UpdateEventRecord :one
UPDATE event_records 
SET name = $2, source = $3, payload = $4, context = $5, timestamp = $6, updated_at = NOW()
WHERE id = $1
RETURNING id, event_id, name, source, payload, context, timestamp,
    environment_id, organization_id, project_id, is_test, created_at, updated_at
`

type UpdateEventRecordParams struct {
	ID        pgtype.UUID        `json:"id"`
	Name      string             `json:"name"`
	Source    string             `json:"source"`
	Payload   []byte             `json:"payload"`
	Context   []byte             `json:"context"`
	Timestamp pgtype.Timestamptz `json:"timestamp"`
}

func (q *Queries) UpdateEventRecord(ctx context.Context, arg UpdateEventRecordParams) (EventRecords, error) {
	row := q.db.QueryRow(ctx, updateEventRecord,
		arg.ID,
		arg.Name,
		arg.Source,
		arg.Payload,
		arg.Context,
		arg.Timestamp,
	)
	var i EventRecords
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.Name,
		&i.Source,
		&i.Payload,
		&i.Context,
		&i.Timestamp,
		&i.EnvironmentID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.IsTest,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
