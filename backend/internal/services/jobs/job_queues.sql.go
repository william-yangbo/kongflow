// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: job_queues.sql

package jobs

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createJobQueue = `-- name: CreateJobQueue :one

INSERT INTO job_queues (
    name, environment_id, job_count, max_jobs
) VALUES ($1, $2, $3, $4)
RETURNING id, name, environment_id, job_count, max_jobs, created_at, updated_at
`

type CreateJobQueueParams struct {
	Name          string      `json:"name"`
	EnvironmentID pgtype.UUID `json:"environment_id"`
	JobCount      int32       `json:"job_count"`
	MaxJobs       int32       `json:"max_jobs"`
}

// job_queues.sql
// JobQueue 作业队列相关查询
func (q *Queries) CreateJobQueue(ctx context.Context, arg CreateJobQueueParams) (JobQueues, error) {
	row := q.db.QueryRow(ctx, createJobQueue,
		arg.Name,
		arg.EnvironmentID,
		arg.JobCount,
		arg.MaxJobs,
	)
	var i JobQueues
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.EnvironmentID,
		&i.JobCount,
		&i.MaxJobs,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const decrementJobCount = `-- name: DecrementJobCount :one
UPDATE job_queues 
SET job_count = GREATEST(job_count - 1, 0), updated_at = NOW()
WHERE id = $1
RETURNING id, name, environment_id, job_count, max_jobs, created_at, updated_at
`

func (q *Queries) DecrementJobCount(ctx context.Context, id pgtype.UUID) (JobQueues, error) {
	row := q.db.QueryRow(ctx, decrementJobCount, id)
	var i JobQueues
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.EnvironmentID,
		&i.JobCount,
		&i.MaxJobs,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteJobQueue = `-- name: DeleteJobQueue :exec
DELETE FROM job_queues WHERE id = $1
`

func (q *Queries) DeleteJobQueue(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteJobQueue, id)
	return err
}

const getJobQueueByID = `-- name: GetJobQueueByID :one
SELECT id, name, environment_id, job_count, max_jobs, created_at, updated_at
FROM job_queues 
WHERE id = $1
`

func (q *Queries) GetJobQueueByID(ctx context.Context, id pgtype.UUID) (JobQueues, error) {
	row := q.db.QueryRow(ctx, getJobQueueByID, id)
	var i JobQueues
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.EnvironmentID,
		&i.JobCount,
		&i.MaxJobs,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getJobQueueByName = `-- name: GetJobQueueByName :one
SELECT id, name, environment_id, job_count, max_jobs, created_at, updated_at
FROM job_queues 
WHERE environment_id = $1 AND name = $2
`

type GetJobQueueByNameParams struct {
	EnvironmentID pgtype.UUID `json:"environment_id"`
	Name          string      `json:"name"`
}

func (q *Queries) GetJobQueueByName(ctx context.Context, arg GetJobQueueByNameParams) (JobQueues, error) {
	row := q.db.QueryRow(ctx, getJobQueueByName, arg.EnvironmentID, arg.Name)
	var i JobQueues
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.EnvironmentID,
		&i.JobCount,
		&i.MaxJobs,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const incrementJobCount = `-- name: IncrementJobCount :one
UPDATE job_queues 
SET job_count = job_count + 1, updated_at = NOW()
WHERE id = $1
RETURNING id, name, environment_id, job_count, max_jobs, created_at, updated_at
`

func (q *Queries) IncrementJobCount(ctx context.Context, id pgtype.UUID) (JobQueues, error) {
	row := q.db.QueryRow(ctx, incrementJobCount, id)
	var i JobQueues
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.EnvironmentID,
		&i.JobCount,
		&i.MaxJobs,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listJobQueuesByEnvironment = `-- name: ListJobQueuesByEnvironment :many
SELECT id, name, environment_id, job_count, max_jobs, created_at, updated_at
FROM job_queues 
WHERE environment_id = $1
ORDER BY name
LIMIT $2 OFFSET $3
`

type ListJobQueuesByEnvironmentParams struct {
	EnvironmentID pgtype.UUID `json:"environment_id"`
	Limit         int32       `json:"limit"`
	Offset        int32       `json:"offset"`
}

func (q *Queries) ListJobQueuesByEnvironment(ctx context.Context, arg ListJobQueuesByEnvironmentParams) ([]JobQueues, error) {
	rows, err := q.db.Query(ctx, listJobQueuesByEnvironment, arg.EnvironmentID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []JobQueues
	for rows.Next() {
		var i JobQueues
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.EnvironmentID,
			&i.JobCount,
			&i.MaxJobs,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateJobQueueCounts = `-- name: UpdateJobQueueCounts :one
UPDATE job_queues 
SET job_count = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, name, environment_id, job_count, max_jobs, created_at, updated_at
`

type UpdateJobQueueCountsParams struct {
	ID       pgtype.UUID `json:"id"`
	JobCount int32       `json:"job_count"`
}

func (q *Queries) UpdateJobQueueCounts(ctx context.Context, arg UpdateJobQueueCountsParams) (JobQueues, error) {
	row := q.db.QueryRow(ctx, updateJobQueueCounts, arg.ID, arg.JobCount)
	var i JobQueues
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.EnvironmentID,
		&i.JobCount,
		&i.MaxJobs,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertJobQueue = `-- name: UpsertJobQueue :one
INSERT INTO job_queues (
    name, environment_id, job_count, max_jobs
) VALUES ($1, $2, $3, $4)
ON CONFLICT (environment_id, name) 
DO UPDATE SET 
    max_jobs = EXCLUDED.max_jobs,
    updated_at = NOW()
RETURNING id, name, environment_id, job_count, max_jobs, created_at, updated_at
`

type UpsertJobQueueParams struct {
	Name          string      `json:"name"`
	EnvironmentID pgtype.UUID `json:"environment_id"`
	JobCount      int32       `json:"job_count"`
	MaxJobs       int32       `json:"max_jobs"`
}

func (q *Queries) UpsertJobQueue(ctx context.Context, arg UpsertJobQueueParams) (JobQueues, error) {
	row := q.db.QueryRow(ctx, upsertJobQueue,
		arg.Name,
		arg.EnvironmentID,
		arg.JobCount,
		arg.MaxJobs,
	)
	var i JobQueues
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.EnvironmentID,
		&i.JobCount,
		&i.MaxJobs,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
