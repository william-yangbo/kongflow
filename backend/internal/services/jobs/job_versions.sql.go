// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: job_versions.sql

package jobs

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countLaterJobVersions = `-- name: CountLaterJobVersions :one
SELECT COUNT(*) 
FROM job_versions 
WHERE job_id = $1 AND environment_id = $2 AND version > $3
`

type CountLaterJobVersionsParams struct {
	JobID         pgtype.UUID `json:"job_id"`
	EnvironmentID pgtype.UUID `json:"environment_id"`
	Version       string      `json:"version"`
}

func (q *Queries) CountLaterJobVersions(ctx context.Context, arg CountLaterJobVersionsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countLaterJobVersions, arg.JobID, arg.EnvironmentID, arg.Version)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createJobVersion = `-- name: CreateJobVersion :one

INSERT INTO job_versions (
    job_id, version, event_specification, properties,
    endpoint_id, environment_id, organization_id, project_id, queue_id,
    start_position, preprocess_runs
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING id, job_id, version, event_specification, properties,
    endpoint_id, environment_id, organization_id, project_id, queue_id,
    start_position, preprocess_runs, created_at, updated_at
`

type CreateJobVersionParams struct {
	JobID              pgtype.UUID      `json:"job_id"`
	Version            string           `json:"version"`
	EventSpecification []byte           `json:"event_specification"`
	Properties         []byte           `json:"properties"`
	EndpointID         pgtype.UUID      `json:"endpoint_id"`
	EnvironmentID      pgtype.UUID      `json:"environment_id"`
	OrganizationID     pgtype.UUID      `json:"organization_id"`
	ProjectID          pgtype.UUID      `json:"project_id"`
	QueueID            pgtype.UUID      `json:"queue_id"`
	StartPosition      JobStartPosition `json:"start_position"`
	PreprocessRuns     bool             `json:"preprocess_runs"`
}

// job_versions.sql
// JobVersion 作业版本相关查询
func (q *Queries) CreateJobVersion(ctx context.Context, arg CreateJobVersionParams) (JobVersions, error) {
	row := q.db.QueryRow(ctx, createJobVersion,
		arg.JobID,
		arg.Version,
		arg.EventSpecification,
		arg.Properties,
		arg.EndpointID,
		arg.EnvironmentID,
		arg.OrganizationID,
		arg.ProjectID,
		arg.QueueID,
		arg.StartPosition,
		arg.PreprocessRuns,
	)
	var i JobVersions
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.Version,
		&i.EventSpecification,
		&i.Properties,
		&i.EndpointID,
		&i.EnvironmentID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.QueueID,
		&i.StartPosition,
		&i.PreprocessRuns,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteJobVersion = `-- name: DeleteJobVersion :exec
DELETE FROM job_versions WHERE id = $1
`

func (q *Queries) DeleteJobVersion(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteJobVersion, id)
	return err
}

const getJobVersionByID = `-- name: GetJobVersionByID :one
SELECT id, job_id, version, event_specification, properties,
    endpoint_id, environment_id, organization_id, project_id, queue_id,
    start_position, preprocess_runs, created_at, updated_at
FROM job_versions 
WHERE id = $1
`

func (q *Queries) GetJobVersionByID(ctx context.Context, id pgtype.UUID) (JobVersions, error) {
	row := q.db.QueryRow(ctx, getJobVersionByID, id)
	var i JobVersions
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.Version,
		&i.EventSpecification,
		&i.Properties,
		&i.EndpointID,
		&i.EnvironmentID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.QueueID,
		&i.StartPosition,
		&i.PreprocessRuns,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getJobVersionByJobAndVersion = `-- name: GetJobVersionByJobAndVersion :one
SELECT id, job_id, version, event_specification, properties,
    endpoint_id, environment_id, organization_id, project_id, queue_id,
    start_position, preprocess_runs, created_at, updated_at
FROM job_versions 
WHERE job_id = $1 AND version = $2 AND environment_id = $3
`

type GetJobVersionByJobAndVersionParams struct {
	JobID         pgtype.UUID `json:"job_id"`
	Version       string      `json:"version"`
	EnvironmentID pgtype.UUID `json:"environment_id"`
}

func (q *Queries) GetJobVersionByJobAndVersion(ctx context.Context, arg GetJobVersionByJobAndVersionParams) (JobVersions, error) {
	row := q.db.QueryRow(ctx, getJobVersionByJobAndVersion, arg.JobID, arg.Version, arg.EnvironmentID)
	var i JobVersions
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.Version,
		&i.EventSpecification,
		&i.Properties,
		&i.EndpointID,
		&i.EnvironmentID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.QueueID,
		&i.StartPosition,
		&i.PreprocessRuns,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLatestJobVersion = `-- name: GetLatestJobVersion :one
SELECT id, job_id, version, event_specification, properties,
    endpoint_id, environment_id, organization_id, project_id, queue_id,
    start_position, preprocess_runs, created_at, updated_at
FROM job_versions 
WHERE job_id = $1 AND environment_id = $2
ORDER BY created_at DESC
LIMIT 1
`

type GetLatestJobVersionParams struct {
	JobID         pgtype.UUID `json:"job_id"`
	EnvironmentID pgtype.UUID `json:"environment_id"`
}

func (q *Queries) GetLatestJobVersion(ctx context.Context, arg GetLatestJobVersionParams) (JobVersions, error) {
	row := q.db.QueryRow(ctx, getLatestJobVersion, arg.JobID, arg.EnvironmentID)
	var i JobVersions
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.Version,
		&i.EventSpecification,
		&i.Properties,
		&i.EndpointID,
		&i.EnvironmentID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.QueueID,
		&i.StartPosition,
		&i.PreprocessRuns,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listJobVersionsByJob = `-- name: ListJobVersionsByJob :many
SELECT id, job_id, version, event_specification, properties,
    endpoint_id, environment_id, organization_id, project_id, queue_id,
    start_position, preprocess_runs, created_at, updated_at
FROM job_versions 
WHERE job_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListJobVersionsByJobParams struct {
	JobID  pgtype.UUID `json:"job_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

func (q *Queries) ListJobVersionsByJob(ctx context.Context, arg ListJobVersionsByJobParams) ([]JobVersions, error) {
	rows, err := q.db.Query(ctx, listJobVersionsByJob, arg.JobID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []JobVersions
	for rows.Next() {
		var i JobVersions
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.Version,
			&i.EventSpecification,
			&i.Properties,
			&i.EndpointID,
			&i.EnvironmentID,
			&i.OrganizationID,
			&i.ProjectID,
			&i.QueueID,
			&i.StartPosition,
			&i.PreprocessRuns,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateJobVersionProperties = `-- name: UpdateJobVersionProperties :one
UPDATE job_versions 
SET properties = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, job_id, version, event_specification, properties,
    endpoint_id, environment_id, organization_id, project_id, queue_id,
    start_position, preprocess_runs, created_at, updated_at
`

type UpdateJobVersionPropertiesParams struct {
	ID         pgtype.UUID `json:"id"`
	Properties []byte      `json:"properties"`
}

func (q *Queries) UpdateJobVersionProperties(ctx context.Context, arg UpdateJobVersionPropertiesParams) (JobVersions, error) {
	row := q.db.QueryRow(ctx, updateJobVersionProperties, arg.ID, arg.Properties)
	var i JobVersions
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.Version,
		&i.EventSpecification,
		&i.Properties,
		&i.EndpointID,
		&i.EnvironmentID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.QueueID,
		&i.StartPosition,
		&i.PreprocessRuns,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertJobVersion = `-- name: UpsertJobVersion :one
INSERT INTO job_versions (
    job_id, version, event_specification, properties,
    endpoint_id, environment_id, organization_id, project_id, queue_id,
    start_position, preprocess_runs
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
ON CONFLICT (job_id, version, environment_id) 
DO UPDATE SET 
    event_specification = EXCLUDED.event_specification,
    properties = EXCLUDED.properties,
    endpoint_id = EXCLUDED.endpoint_id,
    queue_id = EXCLUDED.queue_id,
    start_position = EXCLUDED.start_position,
    preprocess_runs = EXCLUDED.preprocess_runs,
    updated_at = NOW()
RETURNING id, job_id, version, event_specification, properties,
    endpoint_id, environment_id, organization_id, project_id, queue_id,
    start_position, preprocess_runs, created_at, updated_at
`

type UpsertJobVersionParams struct {
	JobID              pgtype.UUID      `json:"job_id"`
	Version            string           `json:"version"`
	EventSpecification []byte           `json:"event_specification"`
	Properties         []byte           `json:"properties"`
	EndpointID         pgtype.UUID      `json:"endpoint_id"`
	EnvironmentID      pgtype.UUID      `json:"environment_id"`
	OrganizationID     pgtype.UUID      `json:"organization_id"`
	ProjectID          pgtype.UUID      `json:"project_id"`
	QueueID            pgtype.UUID      `json:"queue_id"`
	StartPosition      JobStartPosition `json:"start_position"`
	PreprocessRuns     bool             `json:"preprocess_runs"`
}

func (q *Queries) UpsertJobVersion(ctx context.Context, arg UpsertJobVersionParams) (JobVersions, error) {
	row := q.db.QueryRow(ctx, upsertJobVersion,
		arg.JobID,
		arg.Version,
		arg.EventSpecification,
		arg.Properties,
		arg.EndpointID,
		arg.EnvironmentID,
		arg.OrganizationID,
		arg.ProjectID,
		arg.QueueID,
		arg.StartPosition,
		arg.PreprocessRuns,
	)
	var i JobVersions
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.Version,
		&i.EventSpecification,
		&i.Properties,
		&i.EndpointID,
		&i.EnvironmentID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.QueueID,
		&i.StartPosition,
		&i.PreprocessRuns,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
