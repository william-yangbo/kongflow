// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: endpoints.sql

package endpoints

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createEndpoint = `-- name: CreateEndpoint :one
INSERT INTO endpoints (
    slug, url, indexing_hook_identifier,
    environment_id, organization_id, project_id
) VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, slug, url, indexing_hook_identifier,
    environment_id, organization_id, project_id,
    created_at, updated_at
`

type CreateEndpointParams struct {
	Slug                   string      `json:"slug"`
	Url                    string      `json:"url"`
	IndexingHookIdentifier string      `json:"indexing_hook_identifier"`
	EnvironmentID          pgtype.UUID `json:"environment_id"`
	OrganizationID         pgtype.UUID `json:"organization_id"`
	ProjectID              pgtype.UUID `json:"project_id"`
}

type CreateEndpointRow struct {
	ID                     pgtype.UUID        `json:"id"`
	Slug                   string             `json:"slug"`
	Url                    string             `json:"url"`
	IndexingHookIdentifier string             `json:"indexing_hook_identifier"`
	EnvironmentID          pgtype.UUID        `json:"environment_id"`
	OrganizationID         pgtype.UUID        `json:"organization_id"`
	ProjectID              pgtype.UUID        `json:"project_id"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateEndpoint(ctx context.Context, arg CreateEndpointParams) (CreateEndpointRow, error) {
	row := q.db.QueryRow(ctx, createEndpoint,
		arg.Slug,
		arg.Url,
		arg.IndexingHookIdentifier,
		arg.EnvironmentID,
		arg.OrganizationID,
		arg.ProjectID,
	)
	var i CreateEndpointRow
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Url,
		&i.IndexingHookIdentifier,
		&i.EnvironmentID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteEndpoint = `-- name: DeleteEndpoint :exec
DELETE FROM endpoints WHERE id = $1
`

func (q *Queries) DeleteEndpoint(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteEndpoint, id)
	return err
}

const getEndpointByID = `-- name: GetEndpointByID :one
SELECT id, slug, url, indexing_hook_identifier,
    environment_id, organization_id, project_id,
    created_at, updated_at
FROM endpoints 
WHERE id = $1
`

type GetEndpointByIDRow struct {
	ID                     pgtype.UUID        `json:"id"`
	Slug                   string             `json:"slug"`
	Url                    string             `json:"url"`
	IndexingHookIdentifier string             `json:"indexing_hook_identifier"`
	EnvironmentID          pgtype.UUID        `json:"environment_id"`
	OrganizationID         pgtype.UUID        `json:"organization_id"`
	ProjectID              pgtype.UUID        `json:"project_id"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetEndpointByID(ctx context.Context, id pgtype.UUID) (GetEndpointByIDRow, error) {
	row := q.db.QueryRow(ctx, getEndpointByID, id)
	var i GetEndpointByIDRow
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Url,
		&i.IndexingHookIdentifier,
		&i.EnvironmentID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEndpointBySlug = `-- name: GetEndpointBySlug :one
SELECT id, slug, url, indexing_hook_identifier,
    environment_id, organization_id, project_id,
    created_at, updated_at
FROM endpoints 
WHERE environment_id = $1 AND slug = $2
`

type GetEndpointBySlugParams struct {
	EnvironmentID pgtype.UUID `json:"environment_id"`
	Slug          string      `json:"slug"`
}

type GetEndpointBySlugRow struct {
	ID                     pgtype.UUID        `json:"id"`
	Slug                   string             `json:"slug"`
	Url                    string             `json:"url"`
	IndexingHookIdentifier string             `json:"indexing_hook_identifier"`
	EnvironmentID          pgtype.UUID        `json:"environment_id"`
	OrganizationID         pgtype.UUID        `json:"organization_id"`
	ProjectID              pgtype.UUID        `json:"project_id"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetEndpointBySlug(ctx context.Context, arg GetEndpointBySlugParams) (GetEndpointBySlugRow, error) {
	row := q.db.QueryRow(ctx, getEndpointBySlug, arg.EnvironmentID, arg.Slug)
	var i GetEndpointBySlugRow
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Url,
		&i.IndexingHookIdentifier,
		&i.EnvironmentID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateEndpointURL = `-- name: UpdateEndpointURL :one
UPDATE endpoints 
SET url = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, slug, url, indexing_hook_identifier,
    environment_id, organization_id, project_id,
    created_at, updated_at
`

type UpdateEndpointURLParams struct {
	ID  pgtype.UUID `json:"id"`
	Url string      `json:"url"`
}

type UpdateEndpointURLRow struct {
	ID                     pgtype.UUID        `json:"id"`
	Slug                   string             `json:"slug"`
	Url                    string             `json:"url"`
	IndexingHookIdentifier string             `json:"indexing_hook_identifier"`
	EnvironmentID          pgtype.UUID        `json:"environment_id"`
	OrganizationID         pgtype.UUID        `json:"organization_id"`
	ProjectID              pgtype.UUID        `json:"project_id"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateEndpointURL(ctx context.Context, arg UpdateEndpointURLParams) (UpdateEndpointURLRow, error) {
	row := q.db.QueryRow(ctx, updateEndpointURL, arg.ID, arg.Url)
	var i UpdateEndpointURLRow
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Url,
		&i.IndexingHookIdentifier,
		&i.EnvironmentID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertEndpoint = `-- name: UpsertEndpoint :one
INSERT INTO endpoints (
    slug, url, indexing_hook_identifier,
    environment_id, organization_id, project_id
) VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (environment_id, slug) 
DO UPDATE SET 
    url = EXCLUDED.url,
    indexing_hook_identifier = EXCLUDED.indexing_hook_identifier,
    updated_at = NOW()
RETURNING id, slug, url, indexing_hook_identifier,
    environment_id, organization_id, project_id,
    created_at, updated_at
`

type UpsertEndpointParams struct {
	Slug                   string      `json:"slug"`
	Url                    string      `json:"url"`
	IndexingHookIdentifier string      `json:"indexing_hook_identifier"`
	EnvironmentID          pgtype.UUID `json:"environment_id"`
	OrganizationID         pgtype.UUID `json:"organization_id"`
	ProjectID              pgtype.UUID `json:"project_id"`
}

type UpsertEndpointRow struct {
	ID                     pgtype.UUID        `json:"id"`
	Slug                   string             `json:"slug"`
	Url                    string             `json:"url"`
	IndexingHookIdentifier string             `json:"indexing_hook_identifier"`
	EnvironmentID          pgtype.UUID        `json:"environment_id"`
	OrganizationID         pgtype.UUID        `json:"organization_id"`
	ProjectID              pgtype.UUID        `json:"project_id"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpsertEndpoint(ctx context.Context, arg UpsertEndpointParams) (UpsertEndpointRow, error) {
	row := q.db.QueryRow(ctx, upsertEndpoint,
		arg.Slug,
		arg.Url,
		arg.IndexingHookIdentifier,
		arg.EnvironmentID,
		arg.OrganizationID,
		arg.ProjectID,
	)
	var i UpsertEndpointRow
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Url,
		&i.IndexingHookIdentifier,
		&i.EnvironmentID,
		&i.OrganizationID,
		&i.ProjectID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
